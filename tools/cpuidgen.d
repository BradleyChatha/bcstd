/+dub.sdl:
    name "cpuidgen"
    dflags "source/libd/util/cpuid.d" "source/libd/datastructures/_bitinfo.d"
    versions "DLIB_GenCpuID"
+/
// RUN FROM PROJECT ROOT.

// I prioritised writing this code up quickly over outputting efficient code.
// So a future TODO would be to make this better.
// Because right now it repeats a *lot* of stuff it doesn't need to actually do, especially in the NASM code.
import libd.util.cpuid, std;

void main()
{
    Appender!(char[]) nasm;
        Appender!(char[]) nasmStruc;
        Appender!(char[]) nasmMacros;
        Appender!(char[]) nasmFunc;
    Appender!(char[]) d;

    // Start off generating the NASM code
    nasm.put("; This file is generated by tools/cpuidgen.d\n");
    nasm.put("SECTION .text\n");
    nasm.put("global cpuidPopulateStore\n");
    nasmStruc.put("struc cpustore\n");

    nasmFunc.put("cpuidPopulateStore:\n");
    nasmFunc.put("    ; maxLeaf & idString\n");
    nasmFunc.put("    mov r10, PARAM_REG_0\n");
    nasmFunc.put("    xor eax, eax\n");
    nasmFunc.put("    xor ecx, ecx\n");
    nasmFunc.put("    cpuid\n");
    nasmFunc.put("    mov [r10+cpustore.maxLeaf], eax\n");
    nasmFunc.put("    mov [r10+cpustore.idString+0], ebx\n");
    nasmFunc.put("    mov [r10+cpustore.idString+4], edx\n");
    nasmFunc.put("    mov [r10+cpustore.idString+8], ecx\n");

    static foreach(memberName; __traits(allMembers, CpuStore))
    {{
        alias Member = __traits(getMember, CpuStore, memberName);
        const MemberRegister = memberName[$-3..$];

        nasmStruc.put("    .%s: resb %s\n".format(memberName, typeof(Member).sizeof));

        enum Attribs = __traits(getAttributes, Member);
        static if(Attribs.length > 1)
        {
            static assert(Attribs[0].to!string.startsWith("CpuIdLeaf"));
            static assert(MemberRegister[0] == 'e');

            nasmFunc.put("    ; %s - %s - %s\n".format(memberName, MemberRegister, Attribs[0]));
            nasmFunc.put("    mov eax, [r10+cpustore.maxLeaf]\n");
            nasmFunc.put("    cmp eax, [r10+cpustore.maxLeaf]\n");
            nasmFunc.put("    jc .skip_%s\n".format(memberName));
            nasmFunc.put("    mov eax, %s\n".format(Attribs[0].eax));
            nasmFunc.put("    mov ecx, %s\n".format(Attribs[0].ecx));
            nasmFunc.put("    cpuid\n");
            nasmFunc.put("    mov [r10+cpustore.%s], %s\n".format(memberName, MemberRegister));
            nasmFunc.put(".skip_%s:\n".format(memberName));
        }
    }}

    // Generate the D side
    d.put("// This file is generated by tools/cpuidgen.d\n");
    d.put("module libd.util._cpuid;\n\n");
    d.put("import libd.util.cpuid;\n\n");

    d.put("@trusted @nogc nothrow:\n");

    static foreach(memberName; __traits(allMembers, CpuStore))
    {{
        alias Member = __traits(getMember, CpuStore, memberName);
        enum Attribs = __traits(getAttributes, Member);
        static foreach(uda; Attribs)
        {
            static if(uda.to!string.startsWith("Bit("))
            {
                d.put("bool cpuidHas%s() { return (g_cpuidStore.%s & 0x%X) > 0; }\n".format(
                    uda.name.capitalize, memberName, 1 << uda.index
                ));
            }
            else static if(uda.to!string.startsWith("Bits("))
            {
                d.put("uint cpuidGet%s() { return (g_cpuidStore.%s & 0x%X) >> 0x%X; }\n".format(
                    uda.name.capitalize, memberName, uda.getMask, uda.getRightShift
                ));
            }
        }
    }}

    nasmStruc.put("endstruc\n");
    nasmFunc.put("    ret");
    nasm.put(nasmStruc.data);
    nasm.put(nasmMacros.data);
    nasm.put(nasmFunc.data);

    std.file.write("./source/asm/cpuid.nasm", nasm.data);
    std.file.write("./source/libd/util/_cpuid.d", d.data);
}